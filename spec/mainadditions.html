<!doctype html>
<meta charset="utf8">

<emu-clause id="sec-temporal-ecma262-amendments">
  <h1>Amendments to the ECMAScript¬Æ 2023 Language Specification</h1>

  <emu-note type="editor">
    <p>
      This section lists amendments which must be made to <a href="https://tc39.es/ecma262/">ECMA-262, the ECMAScript¬Æ 2023 Language Specification</a>, other than the addition of the new sections specifying the Temporal object and everything related to it.
      Text to be added is marked <ins>like this</ins>, and text to be deleted is marked <del>like this</del>.
    </p>
    <p>
      This text is based on top of the ECMA-262 spec text from commit <a href="https://github.com/tc39/ecma262/commit/fb5e39af09b926f36538bc62b87f5b7b5370f9e7">fb5e39af09b926f36538bc62b87f5b7b5370f9e7</a>.
    </p>
  </emu-note>

  <emu-clause id="sec-literals-numeric-literals">
    <h1><a href="https://tc39.es/ecma262/#sec-literals-numeric-literals">Numeric Literals</a></h1>
    <emu-note type="editor">
      <p>
        No changes, but these productions must be present for symbol references because biblio.json contents are not propagated to grammarkdown.
      </p>
    </emu-note>
    <emu-grammar type="definition">
      NumericLiteralSeparator ::
        `_`

      DecimalDigits[Sep] ::
        DecimalDigit
        DecimalDigits[?Sep] DecimalDigit
        [+Sep] DecimalDigits[+Sep] NumericLiteralSeparator DecimalDigit

      DecimalDigit :: one of
        `0` `1` `2` `3` `4` `5` `6` `7` `8` `9`

      NonZeroDigit :: one of
        `1` `2` `3` `4` `5` `6` `7` `8` `9`
    </emu-grammar>
  </emu-clause>

  <emu-clause id="sec-mathematical-operations">
    <h1>Mathematical Operations</h1>
    <p>[...]</p>
    <p>The notation &ldquo;<emu-eqn id="eqn-modulo" aoid="modulo">_x_ modulo _y_</emu-eqn>&rdquo; (_y_ must be finite and non-zero) computes a value _k_ of the same sign as _y_ (or zero) such that <emu-eqn>abs(_k_) &lt; abs(_y_) and _x_ - _k_ = _q_ &times; _y_</emu-eqn> for some integer _q_.</p>
    <p><ins>The mathematical function <emu-eqn id="eqn-remainder" aoid="remainder">remainder(_x_, _y_)</emu-eqn> produces the mathematical value whose sign is the sign of _x_ and whose magnitude is <emu-eqn>abs(_x_) modulo _y_</emu-eqn>.</ins></p>
    <p>[...]</p>
    <p>Mathematical functions min, max, abs, <ins>remainder,</ins> and floor are not defined for Numbers and BigInts, and any usage of those methods that have non-mathematical value arguments would be an editorial error in this specification.</p>
    <p>[...]</p>
  </emu-clause>

  <emu-clause id="sec-temporal-legacy-date-objects">
    <h1>Date Objects</h1>

    <emu-clause id="sec-temporal-overview-of-legacy-date-objects-and-definitions-of-abstract-operations">
      <h1>Overview of Date Objects and Definitions of Abstract Operations</h1>
      <p>The following abstract operations operate on time values (defined in <emu-xref href="#sec-time-values-and-time-range"></emu-xref>). Note that, in every case, if any argument to one of these functions is *NaN*, the result will be *NaN*.</p>

      <del class="block">
        <emu-clause id="sec-local-time-zone-adjustment" type="implementation-defined abstract operation">
          <h1>
            LocalTZA (
              _t_: a Number,
              _isUTC_: a Boolean,
            ): an integral Number
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>Its return value represents the local time zone adjustment, or offset, in milliseconds. The local political rules for standard time and daylight saving time in effect at _t_ should be used to determine the result in the way specified in this section.</dd>
          </dl>
          <p>When _isUTC_ is true, <emu-eqn>LocalTZA( _t_<sub>UTC</sub>, true )</emu-eqn> should return the offset of the local time zone from UTC measured in milliseconds at time represented by time value <emu-eqn>_t_<sub>UTC</sub></emu-eqn>. When the result is added to <emu-eqn>_t_<sub>UTC</sub></emu-eqn>, it should yield the corresponding Number <emu-eqn>_t_<sub>local</sub></emu-eqn>.</p>
          <p>When _isUTC_ is false, <emu-eqn>LocalTZA( _t_<sub>local</sub>, false )</emu-eqn> should return the offset of the local time zone from UTC measured in milliseconds at local time represented by Number <emu-eqn>_t_<sub>local</sub></emu-eqn>. When the result is subtracted from <emu-eqn>_t_<sub>local</sub></emu-eqn>, it should yield the corresponding time value <emu-eqn>_t_<sub>UTC</sub></emu-eqn>.</p>
          <p>Input _t_ is nominally a time value but may be any Number value. This can occur when _isUTC_ is false and _t_<sub>local</sub> represents a time value that is already offset outside of the time value range at the range boundaries. The algorithm must not limit _t_<sub>local</sub> to the time value range, so that such inputs are supported.</p>
          <p>When <emu-eqn>_t_<sub>local</sub></emu-eqn> represents local time repeating multiple times at a negative time zone transition (e.g. when the daylight saving time ends or the time zone offset is decreased due to a time zone rule change) or skipped local time at a positive time zone transitions (e.g. when the daylight saving time starts or the time zone offset is increased due to a time zone rule change), <emu-eqn>_t_<sub>local</sub></emu-eqn> must be interpreted using the time zone offset before the transition.</p>
          <p>If an implementation does not support a conversion described above or if political rules for time _t_ are not available within the implementation, the result must be *+0*<sub>ùîΩ</sub>.</p>
          <emu-note>
            <p>It is recommended that implementations use the time zone information of the IANA Time Zone Database <a href="https://www.iana.org/time-zones/">https://www.iana.org/time-zones/</a>.</p>
            <p>1:30 AM on 5 November 2017 in America/New_York is repeated twice (fall backward), but it must be interpreted as 1:30 AM UTC-04 instead of 1:30 AM UTC-05. LocalTZA(TimeClip(MakeDate(MakeDay(2017, 10, 5), MakeTime(1, 30, 0, 0))), false) is <emu-eqn>-4 &times; msPerHour</emu-eqn>.</p>
            <p>2:30 AM on 12 March 2017 in America/New_York does not exist, but it must be interpreted as 2:30 AM UTC-05 (equivalent to 3:30 AM UTC-04). LocalTZA(TimeClip(MakeDate(MakeDay(2017, 2, 12), MakeTime(2, 30, 0, 0))), false) is <emu-eqn>-5 &times; msPerHour</emu-eqn>.</p>
            <p>Local time zone offset values may be positive <i>or</i> negative.</p>
          </emu-note>
        </emu-clause>
      </del>

      <emu-clause id="sec-localtime" type="abstract operation">
        <h1>
          LocalTime (
            _t_: a time value,
          ): a Number
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>
            It converts _t_ from UTC to local time.
            <ins>The local political rules for standard time and daylight saving time in effect at _t_ should be used to determine the result in the way specified in this section.</ins>
          </dd>
        </dl>
        <del class="block">
          <emu-alg>
            1. Return _t_ + LocalTZA(_t_, *true*).
          </emu-alg>
        </del>
        <ins class="block">
          <emu-alg>
            1. Let _localTimeZone_ be DefaultTimeZone().
            1. Let _offsetParseResult_ be Completion(ParseTimeZoneOffsetString(_localTimeZone_)).
            1. If _offsetParseResult_ is a normal completion, then
              1. Let _offsetNs_ be _offsetParseResult_.[[Value]].
            1. Else,
              1. Let _offsetNs_ be GetIANATimeZoneOffsetNanoseconds(‚Ñ§(‚Ñù(_t_) &times; 10<sup>6</sup>), _localTimeZone_).
            1. Let _offsetMs_ be RoundTowardsZero(_offsetNs_ / 10<sup>6</sup>).
            1. Return _t_ + ùîΩ(_offsetMs_).
          </emu-alg>
        </ins>
        <p><ins>
          If political rules for the local time _t_ are not available within the implementation, the result is equal to _t_ because DefaultTimeZone returns *"UTC"* and GetIANATimeZoneOffsetNanoseconds returns 0.
        </ins></p>
        <emu-note>
          <p><ins>
            It is recommended that implementations use the time zone information of the IANA Time Zone Database <a href="https://www.iana.org/time-zones/">https://www.iana.org/time-zones/</a>.
          </ins></p>
        </emu-note>
        <emu-note>
          <p>Two different input time values <emu-eqn>_t_<sub>UTC</sub></emu-eqn> are converted to the same local time <emu-eqn>t<sub>local</sub></emu-eqn> at a negative time zone transition when there are repeated times (e.g. the daylight saving time ends or the time zone adjustment is decreased.).</p>
          <p><emu-eqn>LocalTime(UTC(_t_<sub>local</sub>))</emu-eqn> is not necessarily always equal to <emu-eqn>_t_<sub>local</sub></emu-eqn>. Correspondingly, <emu-eqn>UTC(LocalTime(_t_<sub>UTC</sub>))</emu-eqn> is not necessarily always equal to <emu-eqn>_t_<sub>UTC</sub></emu-eqn>.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-utc-t" type="abstract operation">
        <h1>
          UTC (
            _t_: a Number,
          ): a time value
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>
            It converts _t_ from local time to a UTC time value.
            <ins>The local political rules for standard time and daylight saving time in effect at _t_ should be used to determine the result in the way specified in this section.</ins>
          </dd>
        </dl>
        <del class="block">
          <emu-alg>
            1. Return _t_ - LocalTZA(_t_, *false*).
          </emu-alg>
        </del>
        <ins class="block">
          <emu-alg>
            1. Let _localTimeZone_ be DefaultTimeZone().
            1. Let _offsetParseResult_ be Completion(ParseTimeZoneOffsetString(_localTimeZone_)).
            1. If _offsetParseResult_ is a normal completion, then
              1. Let _offsetNs_ be -_offsetParseResult_.[[Value]].
            1. Else,
              1. Let _possibleInstants_ be GetIANATimeZoneEpochValue(_localTimeZone_, ‚Ñù(YearFromTime(_t_)), ‚Ñù(MonthFromTime(_t_)) + 1, ‚Ñù(DateFromTime(_t_)), ‚Ñù(HourFromTime(_t_)), ‚Ñù(MinFromTime(_t_)), ‚Ñù(SecFromTime(_t_)), ‚Ñù(msFromTime(_t_)), 0, 0).
              1. If _possibleInstants_ is not empty, then
                1. Let _disambiguatedInstant_ be _possibleInstants_[0].
              1. Else,
                1. NOTE: _t_ represents a local time skipped at a positive time zone transition (e.g. due to daylight saving time starting or a time zone rule change increasing the UTC offset).
                1. Let _possibleInstants_ be GetIANATimeZoneEpochValue(_localTimeZone_, ‚Ñù(YearFromTime(_tBefore_)), ‚Ñù(MonthFromTime(_tBefore_)) + 1, ‚Ñù(DateFromTime(_tBefore_)), ‚Ñù(HourFromTime(_tBefore_)), ‚Ñù(MinFromTime(_tBefore_)), ‚Ñù(SecFromTime(_tBefore_)), ‚Ñù(msFromTime(_tBefore_)), 0, 0), where _tBefore_ is the largest integral Number &lt; _t_ for which _possibleInstants_ is not empty (i.e., _tBefore_ represents the last local time before the transition).
                1. Let _disambiguatedInstant_ be the last element of _possibleInstants_.
              1. Let _offsetNs_ be GetIANATimeZoneOffsetNanoseconds(_disambiguatedInstant_, _localTimeZone_).
            1. Let _offsetMs_ be RoundTowardsZero(_offsetNs_ / 10<sup>6</sup>).
            1. Return _t_ - ùîΩ(_offsetMs_).
          </emu-alg>
        </ins>
        <p><ins>
          Input _t_ is nominally a time value but may be any Number value.
          The algorithm must not limit _t_ to the time value range, so that inputs corresponding with a boundary of the time value range can be supported regardless of local UTC offset.
          For example, the maximum time value is 8.64 &times; 10<sup>15</sup>, corresponding with *"+275760-09-13T00:00:00Z"*.
          In an environment where the local time zone offset is ahead of UTC by 1 hour at that instant, it is represented by the larger input of 8.64 &times; 10<sup>15</sup> + 3.6 &times; 10<sup>6</sup>, corresponding with *"+275760-09-13T01:00:00+01:00"*.
        </ins></p>
        <p><ins>
          When _t_ represents local time repeating multiple times at a negative time zone transition (e.g. when the daylight saving time ends or the time zone offset is decreased due to a time zone rule change) or skipped local time at a positive time zone transitions (e.g. when the daylight saving time starts or the time zone offset is increased due to a time zone rule change), _t_ is interpreted using the time zone offset before the transition.
        </ins></p>
        <p><ins>
          If political rules for the local time _t_ are not available within the implementation, the result is equal to _t_ because DefaultTimeZone returns *"UTC"* and GetIANATimeZoneOffsetNanoseconds returns 0.
        </ins></p>
        <emu-note>
          <p><ins>
            It is recommended that implementations use the time zone information of the IANA Time Zone Database <a href="https://www.iana.org/time-zones/">https://www.iana.org/time-zones/</a>.
          </ins></p>
          <p><ins>
            1:30 AM on 5 November 2017 in America/New_York is repeated twice (fall backward), but it must be interpreted as 1:30 AM UTC-04 instead of 1:30 AM UTC-05.
            In UTC(TimeClip(MakeDate(MakeDay(2017, 10, 5), MakeTime(1, 30, 0, 0)))), the value of _offsetMs_ is <emu-eqn>-4 &times; msPerHour</emu-eqn>.
          </ins></p>
          <p><ins>
            2:30 AM on 12 March 2017 in America/New_York does not exist, but it must be interpreted as 2:30 AM UTC-05 (equivalent to 3:30 AM UTC-04).
            In UTC(TimeClip(MakeDate(MakeDay(2017, 2, 12), MakeTime(2, 30, 0, 0)))), the value of _offsetMs_ is <emu-eqn>-5 &times; msPerHour</emu-eqn>.
          </ins></p>
        </emu-note>
        <emu-note>
          <p><emu-eqn>UTC(LocalTime(_t_<sub>UTC</sub>))</emu-eqn> is not necessarily always equal to <emu-eqn>_t_<sub>UTC</sub></emu-eqn>. Correspondingly, <emu-eqn>LocalTime(UTC(_t_<sub>local</sub>))</emu-eqn> is not necessarily always equal to <emu-eqn>_t_<sub>local</sub></emu-eqn>.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-temporal-properties-of-the-legacy-date-prototype-object">
      <h1><a href="https://tc39.es/ecma262/#sec-properties-of-the-date-prototype-object">Properties of the Date Prototype Object</a></h1>

      <emu-clause id="sec-date.prototype.tostring">
        <h1>Date.prototype.toString ( )</h1>

        <emu-clause id="sec-timezoneestring" type="abstract operation">
          <h1>
            TimeZoneString (
              _tv_: a Number, but not *NaN*,
            ): a String
          </h1>
          <dl class="header">
          </dl>
          <emu-alg>
            1. <ins>Let _localTimeZone_ be DefaultTimeZone().</ins>
            1. <ins>Let _offsetParseResult_ be Completion(ParseTimeZoneOffsetString(_localTimeZone_)).</ins>
            1. <ins>If _offsetParseResult_ is a normal completion, then</ins>
              1. <ins>Let _offsetNs_ be _offsetParseResult_.[[Value]].</ins>
            1. <ins>Else,</ins>
              1. <ins>Let _offsetNs_ be GetIANATimeZoneOffsetNanoseconds(‚Ñ§(‚Ñù(_t_) &times; 10<sup>6</sup>), _localTimeZone_).</ins>
            1. Let _offset_ be <del>LocalTZA(_tv_, *true*)</del><ins>ùîΩ(RoundTowardsZero(_offsetNs_ / 10<sup>6</sup>))</ins>.
            1. If _offset_ is *+0*<sub>ùîΩ</sub> or _offset_ &gt; *+0*<sub>ùîΩ</sub>, then
              1. Let _offsetSign_ be *"+"*.
              1. Let _absOffset_ be _offset_.
            1. Else,
              1. Let _offsetSign_ be *"-"*.
              1. Let _absOffset_ be -_offset_.
            1. Let _offsetMin_ be ToZeroPaddedDecimalString(‚Ñù(MinFromTime(_absOffset_)), 2).
            1. Let _offsetHour_ be ToZeroPaddedDecimalString(‚Ñù(HourFromTime(_absOffset_)), 2).
            1. Let _tzName_ be an implementation-defined string that is either the empty String or the string-concatenation of the code unit 0x0020 (SPACE), the code unit 0x0028 (LEFT PARENTHESIS), an implementation-defined timezone name, and the code unit 0x0029 (RIGHT PARENTHESIS).
            1. Return the string-concatenation of _offsetSign_, _offsetHour_, _offsetMin_, and _tzName_.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <ins class="block">
        <emu-clause id="sec-date.prototype.totemporalinstant">
          <h1>Date.prototype.toTemporalInstant ( )</h1>
          <p>The following steps are performed:</p>
          <emu-alg>
            1. Let _t_ be ? thisTimeValue(*this* value).
            1. Let _ns_ be ? NumberToBigInt(_t_) &times; ‚Ñ§(10<sup>6</sup>).
            1. Return ! CreateTemporalInstant(_ns_).
          </emu-alg>
        </emu-clause>
      </ins>
    </emu-clause>
  </emu-clause>
</emu-clause>
